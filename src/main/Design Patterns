Design Patterns

### **Aufgabe: Einführung in die 5 meistgenutzten Design Patterns**

**Ziel:**
Du wirst fünf der meistgenutzten Design Patterns kennenlernen, implementieren und ihre Anwendungsfälle erklären. Die Aufgabe besteht darin, zu jedem Pattern ein
kleines Programm oder eine Struktur in einer Programmiersprache deiner Wahl oder in Pseudo-Code zu schreiben. Du sollst außerdem jedes Pattern in eigenen Worten erklären und
Beispiele geben, wann es in der Praxis angewendet wird.

---

### **Schritte der Aufgabe:**

1. **Recherche und Verständnis der 5 häufigsten Design Patterns:**
   - **Singleton:** Stellt sicher, dass eine Klasse nur eine Instanz hat und bietet einen globalen Zugriffspunkt.
   - **Factory:** Stellt eine Methode bereit, um Objekte zu erstellen, ohne die genaue Klasse des Objekts anzugeben.
   - **Observer:** Ermöglicht es, dass ein Objekt über Änderungen in einem anderen Objekt benachrichtigt wird.
   - **Strategy:** Ermöglicht es, ein Verhalten zur Laufzeit auszuwählen, indem verschiedene Algorithmen als separate
   Klassen implementiert werden.
   - **Decorator:** Fügt einer Klasse dynamisch zusätzliche Funktionalitäten hinzu, ohne die Klasse selbst zu ändern.

2. **Implementiere jedes Pattern in Pseudo-Code oder in einer Programmiersprache deiner Wahl.**

3. **Erklärung und Anwendungsfall:**
   - Füge zu jeder Implementierung eine kurze Erklärung hinzu, wie das Pattern funktioniert und in welchen Szenarien es am besten angewendet wird.

4. **Zusammenfassung:**
   - Beschreibe zum Schluss, welches Pattern für dich am sinnvollsten und einfachsten zu verstehen war und warum.
   Erläutere außerdem, ob du in deinen bisherigen Programmierprojekten schon ein solches Pattern genutzt hast oder in
   Zukunft anwenden würdest.

   Singleton:
   -> Grundlagen
   - aus einer Klasse werden Objekte erzeugt
   - das Singleton-Pattern sorgt dafür, dass nur ein Objekt der Klasse entsteht
   - führt zu einer global verfügbaren Klasse

   -> Anwendung
   - wenn man einwas wichtiges abfragen möchte (Leitzins)
   - bei Logging, um die Datenkonsistenz zu gewährleisten
   - für Datenbanken, um Ressourcen zu sparen und Verbindungsmanagement zu vereinfachen

   Factory:
   -> Grundlagen
   - es dient dazu, dass Objekte an einer zentralen Stelle durch den Aufruf einer Methode erzeugt werden können
   - die Daten werden gekapselt
   - die Implementierung kann jederzeit geändert werden ohne das andere Klassen beeinträchtigt werden
   - Übersichtlichkeit wird erhöht da eine Schnittstelle und nicht die ganze Implementierung zur Verfügung gestellt wird
   - wie das Objekt erstellt wird bleibt zentral an einer Stelle

   -> Anwendung
   - Netzwerkprotokolle
   - Parser
   - Spieleentwicklung
   - Datenbankverbindungen
   - GUI

   Observer:
   -> Grundlagen
   - wenn ein Objekt seinen Zustand verändert, sollen die "Beobachter" benachrichtigt werden
   - das kann man machen, indem sich die Beobachter beim Objekt "registrieren"
   - per Pull holt der Beobachter sich die Information, sobald er eine Nachricht erhält, wenn sich der Zustand geändert hat
   - per Push wird der veränderte Zustand direkt mitgesendet

   -> Anwendungen
   - Benachrichtigungssysteme
   - GUI-Frameworks (bei Änderung in der Benutzeroberfläche, werden alle relevanten Komponenten aktualisiert)
   - Datenbank-Trigger (Trigger können als Beobachter fungieren, die auf bestimmte Änderungen in der Datenbank reagieren)
   - Social Media Feeds (wenn ein Benutzer einen neuen Beitrag erstellt, werden alle Follower benachrichtigt)


